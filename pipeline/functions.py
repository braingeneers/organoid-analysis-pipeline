import os 
import pathlib
from PIL import Image, ImageDraw, ImageFilter
import pathlib
import cv2 as cv 
from scipy.spatial import ConvexHull
from scipy.spatial.distance import euclidean
import plotly.graph_objects as go
import plotly.express as px 
import boto3
from statdepth import FunctionalDepth
import numpy as np 
import pandas as pd 
import scipy.signal

here = pathlib.Path(__file__).parent.absolute()
data_path = os.path.join(here, '..', 'data')

BUCKET = 'braingeneers'

def organoid_size(path: str, gaussian=(99, 99)) -> float:
    '''
    Calculates the organoid size from the organoid in the given image path. 

    Parameters:
    path: Path to organoid image
    gaussian: Amount of Gaussian Blur to apply, tuple must be odd numbers and higher numbers mean more blur.

    Returns:
    float: Organoid size 
    '''

    areas = []

    im = cv.imread(path)
    imgray = cv.cvtColor(im, cv.COLOR_BGR2GRAY)
    blurred = cv.GaussianBlur(imgray, gaussian, 0)

    _, thresh = cv.threshold(blurred, 90, 255, 0)
    
    cont, _ = cv.findContours(thresh, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
    if im is None or thresh is None:
        print('Missing values')
    
    for c in cont:
        areas.append(cv.contourArea(c))
    
    areas = list(reversed(sorted(areas)))
    return areas[1] if len(areas) > 1 else -1

def growth_curve(camera, times, skip=4):
    '''
    Visualize the growth curve of an organoid.

    Parameters:
    camera: camera ID as based on the experiment
    times: list of times to visualize for 
    skip: step size in times array slicing

    Returns:
    np.array: 1D numpy array normalized to the largest value of length m for the m time points. 
    '''

    a = []
    for idx, time in enumerate(times[::skip]):
        # Skip time where camera glitched out!
        if time == '2020-12-24T00:11:28':
            continue

        path = os.path.join(here, '..', 'data', camera, time, 'composite.jpg')
        
        o = organoid_size(path, gaussian=(99, 99))
        if o != -1:
            a.append(o)
        else:
            a.append(a[-1])


    a = np.array(a) / max(a) # Normalize to max value
    return a

def irregularity(cont):
    '''
    Calculate irregularity measure for the given contour generated by OpenCV by 
    the ratio of the contour path length to the convex hull generated by the contour path points. 
    
    Parameters:
    cont: contour array generated by cv2

    Returns:
    float: The irregularity measure as described above
    '''

    areas = []
    
    for c in cont:
        areas.append(cv.contourArea(c))
    
    d = dict(zip(areas, cont))
    organoid_contour = d[list(reversed(sorted(areas)))[1]]
    points = np.array([list(p[0]) for p in organoid_contour])
    hull = ConvexHull(points)
    vertices = hull.vertices.tolist() + [hull.vertices[0]]
    
    perimeter = np.sum([euclidean(x, y) for x, y in zip(points[vertices], points[vertices][1:])])
    pathlength = cv.arcLength(organoid_contour ,True)
    
    return pathlength / perimeter

def irregularity_curve(camera, times, skip=4):
    '''
    Generate the irregularity curve for the organoids at the given camera and times.
    
    Parameters:
    cameras: Given camera to calculate irregularity curve from
    times: Array of times to calculate from
    skip: step size in times array, use a higher value for speedup, lower for a better curve

    returns:
    np.array: 1D numpy array of length m for the m times
    '''

    o = []
    for idx, time in enumerate(times[::skip]):
        # Skip time where camera glitched out!
        if time == '2020-12-24T00:11:28':
            continue
            
        path = os.path.join(here, '..', 'data', camera, time, 'composite.jpg')
        img = cv.imread(path)
        gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
        blurred = cv.GaussianBlur(gray, (3, 3), 0)
        _, thresh = cv.threshold(blurred, 90, 255, 0)

        cont, _ = cv.findContours(thresh, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        o.append(irregularity(cont))

    return np.array(o) # Normalize to max value

def savgol_filter(df, wl, po):
    '''
    Transforms the given curves in the given DataFrame using a Savgol filter.
    
    Parameters:
    df: Curve data, each curve should be a discrete curve samples at m times points, where m is the length of the DataFrame axis
    wl: Window length for Savgol filter
    po: Polynomial order for Savgol filter

    Returns:
    pd.DataFrame: Data run through the Savgol filter with the same columns and index as the original DataFrame
    '''

    df_smooth = pd.DataFrame()
    for col in df.columns:
        df_smooth[col] = scipy.signal.savgol_filter(
            x=df.loc[:, col],
            window_length=wl,
            polyorder=po
        )

    return df_smooth

def generate_composite(path, subtitle=''):
    '''Generates a composite image from each image in the given path'''

    files = os.listdir(path)
    composite = Image.open(os.path.join(path, files[0]))
    mask = Image.new("L", composite.size, 128)
    
    for image in files:
        img = Image.open(os.path.join(path, image))
        composite = Image.composite(composite, img, mask)

        composite.save(os.path.join(path, f'composite{subtitle}.jpg'))

def remove_originals(path):
    '''Removes the non-composite images in the given path'''
    files = os.listdir(path)

    for f in files:
        if f != 'composite.jpg':
            os.remove(os.path.join(path, f))
